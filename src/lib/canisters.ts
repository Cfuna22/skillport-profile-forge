
import { Actor, HttpAgent } from '@dfinity/agent';
import { AuthClient } from '@dfinity/auth-client';
import { Principal } from '@dfinity/principal';

// Type definitions matching our Motoko backend
export interface Profile {
  id: Principal;
  name: string;
  bio: string;
  skills: string[];
  projects: Project[];
  endorsements: Endorsement[];
  createdAt: bigint;
}

export interface Project {
  id: string;
  title: string;
  description: string;
  mediaLink: string | null;
  createdAt: bigint;
}

export interface Endorsement {
  id: string;
  fromPrincipal: Principal;
  fromName: string;
  skill: string;
  message: string;
  timestamp: bigint;
}

export type Result<T, E> = { ok: T } | { err: E };

// Canister interface definition
export interface SkillPortBackend {
  registerUser: (name: string, bio: string) => Promise<Result<boolean, string>>;
  updateProfile: (name: string, bio: string) => Promise<Result<boolean, string>>;
  addSkill: (skill: string) => Promise<Result<boolean, string>>;
  removeSkill: (skill: string) => Promise<Result<boolean, string>>;
  addProject: (title: string, description: string, mediaLink: string | null) => Promise<Result<boolean, string>>;
  endorseUser: (targetPrincipal: Principal, skill: string, message: string) => Promise<Result<boolean, string>>;
  getProfile: (userPrincipal: Principal) => Promise<Profile | null>;
  getMyProfile: (caller: Principal) => Promise<Profile | null>;
  listTopProfiles: () => Promise<Profile[]>;
  searchProfilesBySkill: (skill: string) => Promise<Profile[]>;
  getTotalUsers: () => Promise<bigint>;
}

// IDL factory (this would be auto-generated by dfx generate)
const idlFactory = ({ IDL }: any) => {
  const Result = (T: any, E: any) => IDL.Variant({ ok: T, err: E });
  const Time = IDL.Int;
  const Project = IDL.Record({
    id: IDL.Text,
    title: IDL.Text,
    description: IDL.Text,
    mediaLink: IDL.Opt(IDL.Text),
    createdAt: Time,
  });
  const Endorsement = IDL.Record({
    id: IDL.Text,
    fromPrincipal: IDL.Principal,
    fromName: IDL.Text,
    skill: IDL.Text,
    message: IDL.Text,
    timestamp: Time,
  });
  const Profile = IDL.Record({
    id: IDL.Principal,
    name: IDL.Text,
    bio: IDL.Text,
    skills: IDL.Vec(IDL.Text),
    projects: IDL.Vec(Project),
    endorsements: IDL.Vec(Endorsement),
    createdAt: Time,
  });

  return IDL.Service({
    registerUser: IDL.Func([IDL.Text, IDL.Text], [Result(IDL.Bool, IDL.Text)], []),
    updateProfile: IDL.Func([IDL.Text, IDL.Text], [Result(IDL.Bool, IDL.Text)], []),
    addSkill: IDL.Func([IDL.Text], [Result(IDL.Bool, IDL.Text)], []),
    removeSkill: IDL.Func([IDL.Text], [Result(IDL.Bool, IDL.Text)], []),
    addProject: IDL.Func([IDL.Text, IDL.Text, IDL.Opt(IDL.Text)], [Result(IDL.Bool, IDL.Text)], []),
    endorseUser: IDL.Func([IDL.Principal, IDL.Text, IDL.Text], [Result(IDL.Bool, IDL.Text)], []),
    getProfile: IDL.Func([IDL.Principal], [IDL.Opt(Profile)], ['query']),
    getMyProfile: IDL.Func([IDL.Principal], [IDL.Opt(Profile)], ['query']),
    listTopProfiles: IDL.Func([], [IDL.Vec(Profile)], ['query']),
    searchProfilesBySkill: IDL.Func([IDL.Text], [IDL.Vec(Profile)], ['query']),
    getTotalUsers: IDL.Func([], [IDL.Nat], ['query']),
  });
};

let actor: SkillPortBackend | null = null;

export const createActor = async (): Promise<SkillPortBackend> => {
  const authClient = await AuthClient.create();
  const identity = authClient.getIdentity();
  
  const agent = new HttpAgent({
    identity,
    host: process.env.DFX_NETWORK === "local" ? "http://localhost:4943" : "https://ic0.app",
  });

  // Fetch root key for local development
  if (process.env.DFX_NETWORK === "local") {
    await agent.fetchRootKey();
  }

  const canisterId = process.env.VITE_SKILLPORT_BACKEND_CANISTER_ID || "rrkah-fqaaa-aaaaa-aaaaq-cai";
  
  actor = Actor.createActor<SkillPortBackend>(idlFactory, {
    agent,
    canisterId,
  });

  return actor;
};

export const getActor = (): SkillPortBackend => {
  if (!actor) {
    throw new Error('Actor not initialized. Call createActor() first.');
  }
  return actor;
};

// Helper functions to handle Result types
export const handleResult = <T>(result: Result<T, string>): T => {
  if ('ok' in result) {
    return result.ok;
  } else {
    throw new Error(result.err);
  }
};

export const isOk = <T>(result: Result<T, string>): result is { ok: T } => {
  return 'ok' in result;
};
